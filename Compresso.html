<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Compresso</title>
    <!-- Load Tailwind CSS --><script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Custom styles for better aesthetics */
        :root {
            --primary-color: #3b82f6; /* blue-500 */
            --secondary-color: #10b981; /* emerald-500 */
        }
        body {
            font-family: 'Inter', sans-serif;
            background-color: #ffffff; /* Explicitly set body background to white for light theme */
            transition: background-color 0.3s;
        }
        
        /* Light Mode: Ensure pure black for high-contrast elements */
        body:not(.dark) .text-gray-900,
        body:not(.dark) .text-gray-800 {
            color: #000000;
        }

        /* Dark mode styles */
        .dark body {
            background-color: #1f2937; /* gray-800 */
        }

        /* Card base transition */
        .card {
            transition: background-color 0.3s, box-shadow 0.3s, border-color 0.3s;
            border-radius: 0.75rem; /* Equivalent to rounded-xl */
        }

        /* Light Mode Card Styling: Border and Subtle Shadow (As requested) */
        body:not(.dark) .card {
            background-color: #ffffff; /* Explicitly white background for the card */
            border: 1px solid #e5e7eb; /* Light border, subtle definition */
            box-shadow: 0 1px 3px 0 rgba(0, 0, 0, 0.1), 0 1px 2px 0 rgba(0, 0, 0, 0.06); /* Soft shadow */
        }

        /* Dark mode Card Styling */
        .dark .card {
            background-color: #374151; /* Keep dark mode card background */
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.5), 0 4px 6px -2px rgba(0, 0, 0, 0.2);
            border: none; /* No border in dark mode */
        }
        
        .btn-primary {
            transition: background-color 0.2s, transform 0.1s;
        }
        .btn-primary:hover {
            background-color: #2563eb;
            transform: translateY(-1px);
        }
        .btn-secondary {
            transition: background-color 0.2s, transform 0.1s;
        }
        .btn-secondary:hover {
            background-color: #059669;
            transform: translateY(-1px);
        }
        /* Explicit Dark Mode Text Colors for High Contrast */
        .dark .text-gray-900 { color: #ffffff; } 
        .dark .text-gray-800 { color: #f9fafb; } 
        .dark .text-gray-700 { color: #d1d5db; } 
        .dark .text-gray-500 { color: #9ca3af; } 
        .dark .border-gray-300 { border-color: #4b5563; }
        .dark .bg-gray-200 { background-color: #4b5563; }
        
        /* Custom Modal Styling */
        .modal {
            background-color: rgba(0, 0, 0, 0.5);
        }
        .dark .modal-content {
            background-color: #1f2937;
        }
    </style>
</head>
<body class="min-h-screen flex items-center justify-center p-4">

    <!-- Removed bg-white class from the div to be controlled by CSS -->
    <div id="app" class="card dark:bg-gray-700 p-6 md:p-10 rounded-xl w-full max-w-2xl relative">
        
        <!-- Theme Toggle Button --><button id="themeToggle" onclick="toggleTheme()" class="absolute top-4 right-4 p-2 rounded-full text-gray-500 hover:text-gray-900 dark:text-gray-400 dark:hover:text-white transition-colors focus:outline-none">
            <!-- Sun icon (Visible in Light Mode) --><svg id="sunIcon" class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 3v1m0 16v1m9-9h-1M4 12H3m15.364 6.364l-.707-.707M6.343 6.343l-.707-.707m12.728 0l-.707.707M6.343 17.657l-.707.707M16 12a4 4 0 11-8 0 4 4 0 018 0z"></path>
            </svg>
            <!-- Moon icon (Visible in Dark Mode) --><svg id="moonIcon" class="w-6 h-6 hidden" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M20.354 15.354A9 9 0 018.646 3.646 9.003 9.003 0 0012 21a9.003 9.003 0 008.354-5.646z"></path>
            </svg>
        </button>

        <h1 class="text-3xl font-bold mb-6 text-gray-800 dark:text-gray-100 text-center">Compresso</h1>
        
        <!-- File Input Area --><div class="mb-6 border-2 border-dashed border-gray-300 dark:border-gray-500 p-6 rounded-lg text-center">
            <input type="file" id="fileInput" class="hidden" onchange="handleFileSelection(event)" multiple>
            <label for="fileInput" class="cursor-pointer text-blue-600 hover:text-blue-800 dark:text-blue-400 dark:hover:text-blue-200 font-medium">
                Click to select one or more files
            </label>
            <p id="fileNameDisplay" class="mt-2 text-sm text-gray-500 dark:text-gray-400">No file selected.</p>
        </div>

        <!-- Password Input --><input type="password" id="passwordInput" placeholder="Optional Password for Encryption/Decryption" 
               class="w-full p-3 mb-6 rounded-lg border border-gray-300 dark:border-gray-500 bg-white dark:bg-gray-600 dark:text-white text-gray-900 focus:ring-blue-500 focus:border-blue-500 transition">


        <!-- File Status / Sizes --><div id="statusArea" class="space-y-3 mb-6">
            <div id="originalSize" class="text-sm text-gray-800 dark:text-gray-300">Total Original Size: <span class="font-semibold text-gray-900 dark:text-white">N/A</span></div>
            <div id="outputSize" class="text-sm text-gray-800 dark:text-gray-300">Total Output Size: <span class="font-semibold text-gray-900 dark:text-white">N/A</span></div>
            <div id="compressionRatio" class="text-sm text-gray-800 dark:text-gray-300">Ratio: <span class="font-semibold text-gray-900 dark:text-white">N/A</span></div>
            <div id="messageArea" class="p-3 mt-4 text-sm rounded-lg transition-opacity duration-300 opacity-0 hidden"></div>
        </div>

        <!-- Compression Format Information --><div class="p-3 mb-6 rounded-lg bg-gray-100 dark:bg-gray-700 border border-gray-300 dark:border-gray-600">
            <p class="text-xs font-semibold text-gray-700 dark:text-gray-300">
                Compression Format: <span class="text-blue-600 dark:text-blue-400">Gzip (Native Stream)</span>
            </p>
            <p class="text-xs text-gray-600 dark:text-gray-400 mt-1">
                Output File(s): <code class="bg-gray-200 dark:bg-gray-600 p-1 rounded">.gz</code> (no password) or <code class="bg-gray-200 dark:bg-gray-600 p-1 rounded">.gz.enc</code> (with password).
            </p>
        </div>

        <!-- Progress Bar and ETR --><div id="progressContainer" class="mb-6 hidden">
            <div class="flex justify-between items-end mb-1">
                <p class="text-sm font-medium text-gray-800 dark:text-gray-300">Processing...</p>
                <!-- Estimated Time Remaining --><p id="timeRemaining" class="text-xs font-semibold text-blue-600 dark:text-blue-400">Calculating...</p>
            </div>
            <div class="w-full bg-gray-200 dark:bg-gray-600 rounded-full h-2.5">
                <!-- Transition added for smooth filling --><div id="progressBar" class="bg-blue-600 h-2.5 rounded-full transition-all duration-300 ease-out" style="width: 0%"></div>
            </div>
        </div>
        
        <!-- Actions (UPDATED TEXT) --><div class="flex flex-col sm:flex-row gap-4">
            <button id="compressBtn" onclick="processFile('compress')" 
                    class="btn-primary flex-1 bg-blue-500 text-white font-bold py-3 px-4 rounded-lg shadow-md disabled:opacity-50"
                    disabled>
                Compress All Files
            </button>
            <button id="decompressBtn" onclick="processFile('decompress')" 
                    class="btn-secondary flex-1 bg-emerald-500 text-white font-bold py-3 px-4 rounded-lg shadow-md disabled:opacity-50"
                    disabled>
                Decompress All Files
            </button>
        </div>
    </div>

    <!-- Password Prompt Modal (Hidden by default) --><div id="passwordModal" class="modal fixed inset-0 z-50 flex items-center justify-center hidden p-4">
        <div class="modal-content bg-white p-6 rounded-xl shadow-2xl w-full max-w-sm">
            <h3 class="text-xl font-bold mb-4 text-gray-800 dark:text-gray-100">Encrypted File Detected</h3>
            <p class="mb-4 text-sm text-gray-700 dark:text-gray-300">Please enter the password used to encrypt the file(s) for successful decompression.</p>
            <input type="password" id="modalPasswordInput" placeholder="Encryption Password" 
                   class="w-full p-3 mb-4 rounded-lg border border-gray-300 dark:border-gray-500 text-gray-900 dark:text-white bg-white dark:bg-gray-600 focus:ring-blue-500 focus:border-blue-500">
            <button id="modalDecryptBtn" class="w-full bg-blue-500 text-white font-bold py-3 px-4 rounded-lg hover:bg-blue-600 transition">
                Decrypt and Decompress
            </button>
        </div>
    </div>

    <script>
        // Global variables
        let selectedFiles = []; 
        let progressInterval = null; 
        let startTime = null; 
        let isDecrypting = false; // Flag to prevent multiple decryption attempts

        // --- CRYPTO CONSTANTS (Salt/IV sizes) ---
        const SALT_LENGTH = 16; 
        const IV_LENGTH = 12; 
        const PBKDF2_ITERATIONS = 100000;
        const CRYPTO_HEADER_LENGTH = SALT_LENGTH + IV_LENGTH; // 28 bytes

        // --- Theme Management ---
        const toggleTheme = () => {
            const isDark = document.body.classList.toggle('dark');
            localStorage.setItem('theme', isDark ? 'dark' : 'light');
            updateThemeIcons(isDark);
        };

        const updateThemeIcons = (isDark) => {
            document.getElementById('sunIcon').classList.toggle('hidden', isDark);
            document.getElementById('moonIcon').classList.toggle('hidden', !isDark);
        };

        // Initial theme check on load
        document.addEventListener('DOMContentLoaded', () => {
            const savedTheme = localStorage.getItem('theme');
            const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
            
            let isDark = false;
            if (savedTheme === 'dark' || (!savedTheme && prefersDark)) {
                document.body.classList.add('dark');
                isDark = true;
            }
            updateThemeIcons(isDark);
        });
        // -------------------------

        // --- Utility Functions ---

        // Utility: Format bytes into human-readable string
        const formatBytes = (bytes, decimals = 2) => {
            if (bytes === 0) return '0 Bytes';
            const k = 1024;
            const dm = decimals < 0 ? 0 : decimals;
            const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return parseFloat((bytes / Math.pow(k, i)).toFixed(dm)) + ' ' + sizes[i];
        };

        // Utility: Display messages
        const displayMessage = (text, type = 'info') => {
            const area = document.getElementById('messageArea');
            area.textContent = text;
            area.classList.remove('opacity-0', 'hidden', 'bg-red-100', 'text-red-700', 'bg-green-100', 'text-green-700', 'bg-blue-100', 'text-blue-700', 'dark:bg-red-900', 'dark:text-red-100', 'dark:bg-green-900', 'dark:text-green-100', 'dark:bg-blue-900', 'dark:text-blue-100');
            area.classList.add('opacity-100', 'block');
            
            if (type === 'error') {
                area.classList.add('bg-red-100', 'text-red-700', 'dark:bg-red-900', 'dark:text-red-100');
            } else if (type === 'success') {
                area.classList.add('bg-green-100', 'text-green-700', 'dark:bg-green-900', 'dark:text-green-100');
            } else {
                area.classList.add('bg-blue-100', 'text-blue-700', 'dark:bg-blue-900', 'dark:text-blue-100');
            }

            // Hide after 5 seconds
            setTimeout(() => {
                area.classList.remove('opacity-100', 'block');
                area.classList.add('opacity-0', 'hidden');
            }, 5000);
        };

        // Utility: Download the resulting Blob as a file
        const downloadFile = (blob, filename) => {
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url); // Clean up the object URL
        };

        // --- Crypto Functions ---

        // Derive key from password and salt using PBKDF2
        const getKeyFromPassword = async (password, salt) => {
            const encoder = new TextEncoder();
            const keyMaterial = await crypto.subtle.importKey(
                'raw', encoder.encode(password), { name: 'PBKDF2' }, false, ['deriveKey']
            );
            return crypto.subtle.deriveKey(
                {
                    name: 'PBKDF2',
                    salt: salt,
                    iterations: PBKDF2_ITERATIONS,
                    hash: 'SHA-256',
                },
                keyMaterial,
                { name: 'AES-GCM', length: 256 },
                false,
                ['encrypt', 'decrypt']
            );
        };

        // Encrypt data with password
        const encryptData = async (data, password) => {
            const salt = crypto.subtle.getRandomValues(new Uint8Array(SALT_LENGTH));
            const key = await getKeyFromPassword(password, salt);
            const iv = crypto.subtle.getRandomValues(new Uint8Array(IV_LENGTH));
            
            const encryptedContent = await crypto.subtle.encrypt(
                { name: 'AES-GCM', iv: iv }, key, data
            );
            
            // Combine Salt, IV, and Encrypted Data
            const outputBuffer = new ArrayBuffer(CRYPTO_HEADER_LENGTH + encryptedContent.byteLength);
            const outputView = new Uint8Array(outputBuffer);
            
            outputView.set(salt, 0);
            outputView.set(iv, SALT_LENGTH);
            outputView.set(new Uint8Array(encryptedContent), CRYPTO_HEADER_LENGTH);
            
            return outputBuffer; 
        };

        // Decrypt data with password
        const decryptData = async (dataBuffer, password) => {
            if (dataBuffer.byteLength <= CRYPTO_HEADER_LENGTH) {
                 throw new Error("File size is too small or header is corrupted.");
            }

            // Extract Salt and IV
            const salt = new Uint8Array(dataBuffer, 0, SALT_LENGTH);
            const iv = new Uint8Array(dataBuffer, SALT_LENGTH, IV_LENGTH);
            const encryptedContent = dataBuffer.slice(CRYPTO_HEADER_LENGTH);

            const key = await getKeyFromPassword(password, salt);
            
            return crypto.subtle.decrypt(
                { name: 'AES-GCM', iv: iv }, key, encryptedContent
            );
        };
        
        // --- Progress Bar Management ---
        const showProgressBar = () => {
            document.getElementById('progressContainer').classList.remove('hidden');
            document.getElementById('progressBar').style.width = '0%';
            document.getElementById('timeRemaining').textContent = 'Calculating...';
        };

        const hideProgressBar = () => {
            if (progressInterval) {
                clearInterval(progressInterval);
                progressInterval = null;
            }
            startTime = null; 
            
            document.getElementById('progressBar').style.width = '100%'; 
            document.getElementById('timeRemaining').textContent = 'Complete';
            
            setTimeout(() => {
                document.getElementById('progressContainer').classList.add('hidden');
            }, 500); 
        };
        
        const setProgress = (percentage) => {
            document.getElementById('progressBar').style.width = `${Math.min(100, percentage)}%`;
        };

        const formatTime = (ms) => {
            if (ms < 0) return '0.0s Remaining';
            const seconds = (ms / 1000).toFixed(1);
            return `${seconds}s Remaining`;
        }

        const startProgressSimulation = (fileSize) => {
            showProgressBar();
            startTime = Date.now();
            
            let estimatedTotalDurationMs = 1500; // Base time increased slightly for crypto overhead
            const sizeMB = fileSize / (1024 * 1024);
            
            if (sizeMB > 100) {
                estimatedTotalDurationMs = 7000;
            } else if (sizeMB > 10) {
                estimatedTotalDurationMs = 5000;
            } else if (sizeMB > 1) {
                estimatedTotalDurationMs = 3000;
            } 
            
            estimatedTotalDurationMs = Math.max(500, estimatedTotalDurationMs);

            progressInterval = setInterval(() => {
                if (!startTime) {
                    clearInterval(progressInterval);
                    return;
                }
                const elapsed = Date.now() - startTime;
                
                let progress = (elapsed / estimatedTotalDurationMs) * 100;
                let remainingTime = estimatedTotalDurationMs - elapsed;

                if (progress >= 99) {
                    progress = 99; 
                    remainingTime = 0;
                }

                setProgress(progress);
                document.getElementById('timeRemaining').textContent = formatTime(remainingTime);

                if (elapsed >= estimatedTotalDurationMs * 2) {
                    clearInterval(progressInterval);
                }
            }, 50); 
        };
        // -------------------------------


        // Step 1: Handle File Input (Updated for multi-file)
        const handleFileSelection = (event) => {
            const files = event.target.files;
            if (files.length > 0) {
                selectedFiles = Array.from(files);
                
                const totalSize = selectedFiles.reduce((sum, file) => sum + file.size, 0);
                
                document.getElementById('fileNameDisplay').textContent = 
                    `Selected ${selectedFiles.length} file(s). (Total Size: ${formatBytes(totalSize)})`;
                
                document.getElementById('originalSize').querySelector('span').textContent = formatBytes(totalSize);
                document.getElementById('outputSize').querySelector('span').textContent = 'N/A';
                document.getElementById('compressionRatio').querySelector('span').textContent = 'N/A';
                
                document.getElementById('compressBtn').disabled = false;
                
                // Check if ANY selected file is a Gzip or Encrypted file to enable decompression
                const hasGzip = selectedFiles.some(f => f.name.toLowerCase().endsWith('.gz') || f.name.toLowerCase().endsWith('.enc'));
                document.getElementById('decompressBtn').disabled = !hasGzip;

                if (!hasGzip) {
                    displayMessage('Select at least one .gz or .enc file to enable decompression.', 'info');
                }
            } else {
                selectedFiles = [];
                document.getElementById('fileNameDisplay').textContent = `No file selected.`;
                document.getElementById('originalSize').querySelector('span').textContent = 'N/A';
                document.getElementById('outputSize').querySelector('span').textContent = 'N/A';
                document.getElementById('compressionRatio').querySelector('span').textContent = 'N/A';
                document.getElementById('compressBtn').disabled = true;
                document.getElementById('decompressBtn').disabled = true;
            }
        };

        // Core Compression Logic for a single file (returns output size)
        const compressSingleFile = async (file, password) => {
            // Use file.stream() for chunked reading, which is essential for large files.
            const readableStream = file.stream();
            
            // 1. Gzip Compression (Streaming)
            const compressedStream = readableStream.pipeThrough(new CompressionStream('gzip'));
            
            // WARNING: The resulting compressed stream must be converted back to a Blob/Buffer 
            // for the AES-GCM encryption step (if password is set), which requires the full data size. 
            // This is the memory bottleneck for multi-GB files.
            const compressedBlob = await new Response(compressedStream).blob();
            let finalBuffer = await compressedBlob.arrayBuffer(); 
            
            let outputFilename = file.name + '.gz';

            // 2. Optional Encryption (Applied to the compressed buffer)
            if (password) {
                finalBuffer = await encryptData(finalBuffer, password);
                outputFilename += '.enc'; // Add .enc extension if encrypted
            }

            // Final file saving
            const finalBlob = new Blob([finalBuffer], { type: 'application/octet-stream' });
            const finalSize = finalBuffer.byteLength;
            
            // Clean up double extensions if they occur (e.g., file.txt.gz.enc)
            if (outputFilename.endsWith('.gz.gz.enc')) {
                outputFilename = outputFilename.slice(0, -7) + '.gz.enc';
            } else if (outputFilename.endsWith('.gz.gz')) {
                outputFilename = outputFilename.slice(0, -3);
            }

            downloadFile(finalBlob, outputFilename);
            return finalSize;
        };

        // Core Decompression Logic for a single file (returns output size)
        const decompressSingleFile = async (file, passwordOverride) => {
            let buffer = await file.arrayBuffer();
            let originalFilename = file.name;
            let outputFilename = originalFilename;
            let finalDecompressedBuffer;
            
            const isEncrypted = buffer.byteLength > CRYPTO_HEADER_LENGTH && 
                                (originalFilename.toLowerCase().endsWith('.gz.enc') || originalFilename.toLowerCase().endsWith('.enc.gz'));

            // 1. Optional Decryption
            if (isEncrypted) {
                // If we are in the main process loop and need a password
                if (!passwordOverride) {
                    return { isEncrypted: true, file: file }; // Signal that decryption is needed
                }
                
                try {
                    buffer = await decryptData(buffer, passwordOverride);
                    outputFilename = outputFilename.replace(/\.enc$/i, '');
                    outputFilename = outputFilename.replace(/\.enc\.gz$/i, '.gz');
                    // Buffer now holds the Gzip compressed data
                } catch (e) {
                    throw new Error("Decryption failed. Invalid password or corrupted file.");
                }
            } else if (originalFilename.toLowerCase().endsWith('.enc')) {
                displayMessage('File ends with .enc but does not contain valid encryption header. Attempting regular decompression.', 'info');
            }


            // 2. Gzip Decompression
            const readableStream = new ReadableStream({
                start(controller) {
                    controller.enqueue(buffer);
                    controller.close();
                }
            });

            try {
                const decompressedStream = readableStream.pipeThrough(new DecompressionStream('gzip'));
                const decompressedBlob = await new Response(decompressedStream).blob();
                finalDecompressedBuffer = await decompressedBlob.arrayBuffer();

                // 3. Determine Output Filename
                if (outputFilename.toLowerCase().endsWith('.gz')) {
                    outputFilename = outputFilename.slice(0, -3);
                } else {
                    // Fallback for non-.gz files
                    const parts = outputFilename.split('.');
                    parts.splice(parts.length - 1, 0, 'decompressed');
                    outputFilename = parts.join('.');
                }
                
                downloadFile(decompressedBlob, outputFilename);
                return { size: finalDecompressedBuffer.byteLength, isEncrypted: false };

            } catch (e) {
                console.error("Decompression error:", e);
                // If decompression fails, it might be due to a non-compressed file or bad data
                if (isEncrypted) {
                    // If decryption succeeded but decompression failed, it was likely a wrong password leading to garbage data.
                    throw new Error("Decompression failed after decryption. Check your password or file integrity.");
                } else {
                    // If no encryption was involved, it's just a file format error.
                    throw new Error("Decompression failed. Is this a valid Gzip file?");
                }
            }
        };


        // --- Main Controller and Modal Logic ---

        const promptForPassword = (encryptedFiles) => {
            return new Promise((resolve) => {
                const modal = document.getElementById('passwordModal');
                const decryptBtn = document.getElementById('modalDecryptBtn');
                const passwordInput = document.getElementById('modalPasswordInput');

                modal.classList.remove('hidden');

                const handleDecrypt = async () => {
                    const password = passwordInput.value.trim();
                    if (!password) {
                        displayMessage('Password required for encrypted files.', 'error');
                        return;
                    }
                    
                    decryptBtn.disabled = true;
                    decryptBtn.textContent = 'Processing...';

                    // Hide modal and resolve the promise with the password
                    modal.classList.add('hidden');
                    passwordInput.value = ''; // Clear password
                    decryptBtn.disabled = false;
                    decryptBtn.textContent = 'Decrypt and Decompress';
                    resolve(password);
                };

                // Setup listener (will be removed on resolve/reject)
                decryptBtn.onclick = handleDecrypt;
                passwordInput.onkeydown = (e) => {
                    if (e.key === 'Enter') handleDecrypt();
                };
            });
        };

        // Step 4: Main Controller (Updated for batch processing and encryption)
        const processFile = async (mode) => {
            if (selectedFiles.length === 0) {
                return displayMessage('Please select one or more files first.', 'error');
            }
            if (isDecrypting) {
                return displayMessage('A decryption process is already running.', 'info');
            }

            const password = document.getElementById('passwordInput').value.trim();
            if (mode === 'compress' && password) {
                displayMessage('Compression will include AES-GCM encryption. Save your password securely!', 'info');
            }

            let filesToProcess = [];
            if (mode === 'compress') {
                filesToProcess = selectedFiles;
            } else { // mode === 'decompress'
                filesToProcess = selectedFiles.filter(f => f.name.toLowerCase().endsWith('.gz') || f.name.toLowerCase().endsWith('.enc'));
                if (filesToProcess.length === 0) {
                    return displayMessage('No Gzip (.gz) or Encrypted (.enc) files selected for decompression.', 'error');
                }
            }

            const totalBatchSize = filesToProcess.reduce((sum, file) => sum + file.size, 0);

            // Disable buttons and show loading state
            document.getElementById('compressBtn').disabled = true;
            document.getElementById('decompressBtn').disabled = true;
            displayMessage(`${mode === 'compress' ? 'Compressing' : 'Decompressing'} ${filesToProcess.length} file(s)... This may take a moment.`, 'info');
            
            startProgressSimulation(totalBatchSize); 

            let successfulDownloads = 0;
            let totalOutputSize = 0;
            let passwordOverride = null;
            let requiresPassword = false;
            let encryptedFiles = [];

            try {
                isDecrypting = true;
                
                // 1. First Pass: Process all files
                for (const file of filesToProcess) {
                    if (mode === 'compress') {
                        const size = await compressSingleFile(file, password);
                        totalOutputSize += size;
                        successfulDownloads++;
                    } else { // Decompress
                        let result = await decompressSingleFile(file, passwordOverride);
                        
                        if (result.isEncrypted) {
                            requiresPassword = true;
                            encryptedFiles.push(file);
                        } else {
                            totalOutputSize += result.size;
                            successfulDownloads++;
                        }
                    }
                }
                
                // 2. Second Pass (if decryption is needed)
                if (requiresPassword && mode === 'decompress') {
                    // Try to use the password from the main input first
                    if (!password) {
                        // Prompt user via modal
                        passwordOverride = await promptForPassword(encryptedFiles);
                    } else {
                        passwordOverride = password;
                    }

                    // Now process encrypted files with the obtained password
                    for (const file of encryptedFiles) {
                         const result = await decompressSingleFile(file, passwordOverride);
                         if (result.isEncrypted) {
                            // This should not happen if the prompt logic worked, but as a fallback:
                            throw new Error(`Failed to decrypt file: ${file.name}. Wrong password.`);
                         }
                         totalOutputSize += result.size;
                         successfulDownloads++;
                    }
                }
                
                // Final UI updates for the batch
                const originalSize = totalBatchSize;
                const ratio = (1 - (totalOutputSize / originalSize)) * 100;

                document.getElementById('outputSize').querySelector('span').textContent = formatBytes(totalOutputSize);
                document.getElementById('compressionRatio').querySelector('span').textContent = 
                    mode === 'compress' ? `${ratio.toFixed(2)}% reduction` : 'Decompressed';
                
                displayMessage(`${successfulDownloads} file(s) processed and downloaded successfully!`, 'success');

            } catch (error) {
                console.error(`${mode} Batch Error:`, error);
                // Handle crypto errors
                displayMessage(error.message || `An unexpected error occurred during ${mode}.`, 'error');
            } finally {
                // Reset state and re-enable buttons
                hideProgressBar();
                isDecrypting = false; 
                
                document.getElementById('compressBtn').disabled = (selectedFiles.length === 0);
                const hasGzip = selectedFiles.some(f => f.name.toLowerCase().endsWith('.gz') || f.name.toLowerCase().endsWith('.enc'));
                document.getElementById('decompressBtn').disabled = !hasGzip;
            }
        }; 
    </script>
</body>
</html>